# My Gists (add_comments branch)

This README would normally document whatever steps are necessary to get the
application up and running.

. Ruby version – *2.4.1*, Rails – *5.0.2*
. Uses https://github.com/jneen/rouge[rouge gem] –
  a pure-ruby code highlighter that is compatible with _pygments_.
. https://www.railstutorial.org/book/beginning#sec-deploying[Deployment instructions for Heroku]
  by M. Hartl
. http://edgeguides.rubyonrails.org/getting_started.html#adding-a-second-model[Adding a Second Model]
+
Ten kod jest na gałęzi _add_comments_
+
```sh
git checkout --track origin/add_comments
```

Tutorials:

. https://www.railstutorial.org/book/beginning#sec-deploying[Deployment instructions for Heroku]
  by M. Hartl
. http://edgeguides.rubyonrails.org/getting_started.html#adding-a-second-model[Adding a Second Model]


Responders (_responders_ branch contains an example – adding remarks to gists):

* https://github.com/plataformatec/responders[gem responders]
* also includes a responders controller generator, so your scaffold
  can be customized to use respond_with instead of default respond_to blocks.
+
you need to explicitly opt-in to use this generator by adding the following
to your _config/application.rb_:
```ruby
config.app_generators.scaffold_controller :responders_controller
```


## 6 Adding a second model

The second model will handle comments on gists.

### 6.1 Generating a Model

```sh
bin/rails generate model Comment commenter:string body:text gist:references
# check generated files models/comments.rb and migration
bin/rails db:migrate
```

### 6.2 Associating Models

* Each comment belongs to one gist.
* One gist can have many comments.

```ruby
class Gist < ApplicationRecord
  has_many :comments
  validates :src, presence: true, length: { minimum: 8, maximum: 256 }
end
```

### 6.3 Adding a Route for Comments

Update _config/routes.rb_.

```ruby
resources :gist do
  resources :comments
end
```

Check routing.

```sh
rails routes
```

### 6.4 Generating a Controller

```ruby
bin/rails generate controller Comments
```

Users will create their comments directly after reading the gist, and once
they have added their comment, will be sent back to the gist show page to see
their comment now listed.

_CommentsController_ is there to provide a method to create comments and
delete spam comments when they arrive.

First update the _Gist_ show template.

```html
<h2>Add a comment</h2>
<%= form_for([@gist, @gist.comments.build]) do |f| %>
  <p><%= f.label :commenter %><br><%= f.text_field :commenter %></p>
  <p><%= f.label :body %><br><%= f.text_area :body %></p>
  <p><%= f.submit %></p>
<% end %>
```

Now, wire up the create in _comments_controller.rb_.

```ruby
class CommentsController < ApplicationController
  def create
    @gist = Gist.find(params[:gist_id])
    @comment = @gist.comments.create(comment_params)
    redirect_to gist_path(@gist)
  end

  private

  def comment_params
    params.require(:comment).permit(:commenter, :body)
  end
end
```

Update one more _Gist_ show template.

```html
<% @gist.comments.each do |comment| %>
  <p><strong>Commenter:</strong><%= comment.commenter %></p>
  <p><strong>Comment:</strong><%= comment.body %></p>
<% end %>
```


## 7 Refactoring

Take a look at the _articles/show.html.erb_ template.
It looks amateurish. It is long. It is unreadable.

### 7.1 Rendering Partial Collections – implicit loop

Create a comment partial _comments/_comment.html.erb_:
```html
<p>
  <strong>Commenter:</strong><%= comment.commenter %>
</p>
<p>
  <strong>Comment:</strong><%= comment.body %>
</p>
```

Change _articles/show.html.erb_:
```html
<h2>Comments</h2>
<%= render @gist.comments %>
```

Now the partial _comments/_comment.html.erb_ will be used once for each comment
that is in the _@gist.comments_ collection.

### 7.2 Rendering a Partial Form

Move that new comment section out to its own partial, _comments/_form.html.erb_:
```html
<%= form_for([@gist, @gist.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br>
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br>
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>
```

And update _gists/show.html.erb_:
```html
<h2>Add a comment</h2>
<%= render 'comments/form' %>
```

### Remark

Bootstraped views looks ugly and should be refactored.
See *View Objects (Serializer/Presenter)* and *Decorators* sections in
https://www.sitepoint.com/7-design-patterns-to-refactor-mvc-components-in-rails/[7 Design Patterns to Refactor MVC Components in Rails]
for examples how to do it.


## 8 Deleting Comments

Important feature is being able to delete spam comments.
To do this, we need to implement a link of some sort in the view and a `destroy`
action in the `CommentsController`.

Add the delete link in the _comments/_comment.html.erb_ partial:
```html
<p>
  <%= link_to 'Destroy Comment', [comment.gist, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' },
               class: 'btn btn-danger' %>
</p>
```

Add a destroy action to _controllers/comments_controller.rb_:
```ruby
class CommentsController < ApplicationController

  def destroy
    @gist = Gist.find(params[:gist_id])
    @comment = @gist.comments.find(params[:id])
    @comment.destroy
    redirect_to gist_path(@gist)
  end
```

### 8.1 Deleting Associated Objects

Assume that deleting an gist, deletes associated comments.

```ruby
class Gist < ApplicationRecord
  has_many :comments, dependent: :destroy # changed line: added dependent
  validates :src, presence: true, length: { minimum: 8, maximum: 1024 }
end
```







#
